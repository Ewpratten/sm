# Turnstile (macro)

This example uses the `sm` macro to implement a [turnstile state machine][wiki].

The implementation is similar to the [Turnstile (manual) example][example],
except that it uses the provided `sm` macro to declaratively define our state
machine logic, and have the Rust compiler implement the required code on compile
time.

The state machine is defined like this:

```rust
TurnStile {
    InitialStates { Locked }

    Push { Unlocked, Locked => Locked }
    Coin { Unlocked, Locked => Unlocked }
}
```

[wiki]: https://en.wikipedia.org/wiki/Finite-state_machine#Example:_coin-operated_turnstile
[example]: ../turnstile-manual

## How it works

This is a simple example that switches the `TurnStile` state machine between the
`Locked` and `Unlocked` state, until a total of 100 coins have been inserted, at
which point the program terminates.

You can run the program using `cargo run --example turnstile-macro`.

By enabling `println!("coins: {}", coins);` at the last line, we can see the
program printing `coins: 100` to the terminal, which verifies that the state
transitions work as expected.

In this example, we use the `as_enum()` method on the state machine to be able
to pattern match against all possible machine states.

For more details on how the implementation works, see the inline code comments.

## Generated Assembly

Using [`cargo-asm`][asm], we can print the final Assembly code<sup>1</sup>
generated by the Rust compiler (with the relevant Rust code inlined, for easier
readability). This shows us how the state machine code disappears from the final
binary. This is because `sm` is completely static, and everything is validated
at compile time, no extra runtime logic is required.

Most of what remains is the incrementing of `coins` (`inc     eax`), comparing
if it's equal to 100 (`cmp     eax, 100`), and the process of transitioning
between the locked and unlocked states using jumps (`jne     LBB4_1` and
`je      LBB4_4`):

```assembly
 fn main() {
 push    rbp
 mov     rbp, rsp
 xor     ecx, ecx
 xor     eax, eax
 jmp     LBB4_1
LBB4_3:
 coins += 1;
 inc     eax
 mov     cl, 1
LBB4_1:
 Variant::InitialLocked(m) => m.transition(Push).as_enum(),
 and     cl, 3
 cmp     cl, 1
 je      LBB4_4
 cmp     cl, 2
 mov     cl, 1
 jne     LBB4_1
 jmp     LBB4_3
LBB4_4:
 mov     cl, 2
 cmp     eax, 100
 if coins == 100 {
 jne     LBB4_1
 }
 pop     rbp
 ret
```

<sup>1</sup>: the last `println` line is disabled to focus the final result on
the state machine itself and the logic of incrementing the counter.

[asm]: https://github.com/gnzlbg/cargo-asm
