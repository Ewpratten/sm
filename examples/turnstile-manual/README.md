# Turnstile (manual)

This example uses only traits to implement a [turnstile state machine][wiki].

Because the state machine is completely static, we cannot rely on any runtime
logic, but have to implement our states and events as concrete types. This
results in quite a lot of boilerplate code. So, even though this is a good
example to show how `sm` builds the state machines under the hood, and to show
that it's possible to do so without any macro's, it's far more egronomic to use
the provided `sm` macro to let this library do the work for you instead.

See the [Turnstile (macro) example][example] to see how the exact same
implementation can be written in a declarative way, using the provided macro.

[wiki]: https://en.wikipedia.org/wiki/Finite-state_machine#Example:_coin-operated_turnstile
[example]: ../turnstile-macro

## How it works

This is a simple example that switches the `TurnStile` state machine between the
`Locked` and `Unlocked` state, until a total of 100 coins have been inserted, at
which point the program terminates.

You can run the program using `cargo run --example turnstile-manual`.

By enabling `println!("coins: {}", coins);` at the last line, we can see the
program printing `coins: 100` to the terminal, which verifies that the state
transitions work as expected.

In this example, we use the `as_enum()` method on the state machine to be able
to pattern match against all possible machine states.

For more details on how the implementation works, see the inline code comments.

## Generated Assembly

Using [`cargo-asm`][asm], we can print the final Assembly code<sup>1</sup>
generated by the Rust compiler (with the relevant Rust code inlined, for easier
readability). This shows us how the state machine code disappears from the final
binary. This is because `sm` is completely static, and everything is validated
at compile time, no extra runtime logic is required.

Most of what remains is the incrementing of `coins` (`inc     eax`), comparing
if it's equal to 100 (`cmp     eax, 100`), and the process of transitioning
between the locked and unlocked states using jumps (`jne     LBB4_1` and
`je      LBB4_5`):

```assembly
 fn main() {
 push    rbp
 mov     rbp, rsp
 xor     ecx, ecx
 xor     eax, eax
 jmp     LBB4_1
LBB4_5:
 coins += 1;
 inc     eax
 mov     cl, 2
LBB4_1:
 Variant::InitialLocked(m) => m.transition(Push).as_enum(),
 and     cl, 3
 cmp     cl, 1
 je      LBB4_5
 cmp     cl, 2
 mov     cl, 2
 jne     LBB4_1
 mov     cl, 1
 cmp     eax, 100
 if coins == 100 {
 jne     LBB4_1
 }
 pop     rbp
 ret
```

<sup>1</sup>: the last `println` line is disabled to focus the final result on
the state machine itself and the logic of incrementing the counter.

[asm]: https://github.com/gnzlbg/cargo-asm
